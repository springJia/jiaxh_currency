阅读======>https://github.com/inoutcode/ethereum_book/blob/master

⚠️：web3.js-->是一组库，允许您使用HTTP或IPC连接与本地或远程以太它节点进行交互。
           为了让你的Ðapp运行上以太坊，一种选择是使用web3.js library提供的web3。对象。底层实现上，它通过RPC 调用与本地节点通信。web3.js可以与任何暴露了RPC接口的以太坊节点连接。
           web3中有eth对象 - web3.eth 具体来表示与以太坊区块链之间的交互。shh对象 - web3.shh表示Whisper协议的相关交互。后续我们会继续介绍其它一些web3协议中的对象
⚠️ 测试币获取地址：https://faucet.metamask.io/
⚠️ Remix是solidity编辑工具:https://remix.ethereum.org/

2.账户 Account:    包含地址、余额，随机数，以及可选存储和代码的对象。账户可以是合约账户或外部拥有账户（EOA，externally owned account）.

3.比特币改进提议 BIP:比特币改进提议，Bitcoin Improvement Proposals。比特币社区成员提交的一组提案，旨在改进比特币。例如，BIP-21是改进比特币统一资源标识符（URI）方案的建议。

4.区块 Block:      区块是关于所包含的交易的所需信息（区块头）的集合，以及称为ommer的一组其他区块头。它被矿工添加到以太坊网络中。

5.椭圆曲线数字签名算法 ECDSA:椭圆曲线数字签名算法（ Elliptic Curve Digital Signature Algorithm，ECDSA ）是以太坊用来确保资金只能由合法所有者使用的加密算法

6.Keccak256               :以太坊使用的加密哈希方法，Keccak256 被标准化为 SHA-3.

7.水龙头 Faucet：一个网站，为想要在testnet上做测试的开发人员提供免费测试以太形式的奖励。

8.Ganache：私有以太坊区块链，你可以在上面进行测试，执行命令，在控制区块链如何运作时检查状态。

9.燃气 Gas:以太坊用于执行智能合约的虚拟燃料。以太坊虚拟机使用会计机制来衡量天然气的消耗量并限制计算资源的消耗。参见“图灵完备”,
燃气是执行智能合约的每条指令产生的计算单位。燃气与以太加密货币挂钩。燃气类似于蜂窝网络上的通话时间

10.燃气限制 Gas limit：在谈论区块时，它们也有一个名为燃气限制的区域。它定义了整个区块中所有交易允许消耗的最大燃气量

11.硬分叉 Hard fork:硬分叉也称为硬分叉更改，是区块链中的一种永久性分歧，通常发生在非升级节点无法验证升级节点创建的遵循新共识规则的区块时。不要与分叉，软分叉，软件分叉或Git分叉混淆。

12.哈希值 Hash:通过哈希方法为可变大小的数据生成的固定长度的指纹

13.节点 Node:参与到对等网络的软件客户端。

14.随机数 Nonce:密码学中，随机数指代只可以用一次的数值。在以太坊中用到两类随机数。
账户随机数 - 这只是一个账户的交易计数。
工作量证明随机数- 用于获得工作证明的区块中的随机值（取决于当时的难度）。

15.Ommer:父节点的子节点，但它本身并不是父节点。当矿工找到一个有效的区块时，另一个矿工可能已经发布了一个竞争的区块，并添加到区块链顶部。像比特币一样，以太坊中的孤儿区块可以被新的区块作为ommers包含，并获得部分奖励。术语 "ommer" 是对父节点的兄弟姐妹节点的性别中立的称呼，但也可以表示为“叔叔

16.Parity:以太坊客户端软件最突出的互操作实现之一。

17.收据 Receipt:以太坊客户端返回的数据，表示特定交易的结果，包括交易的哈希值，其区块编号，使用的燃气量，以及在部署智能合约时的合约地址。

18.密钥推导方法 Key Derivation Function (KDF)：也称为密码扩展算法，它被keystore格式使用，以防止对密码加密的暴力破解，字典或彩虹表攻击。它重复对密码进行哈希。

19.Swarm：一种去中心化（P2P）的存储网络。与Web3和Whisper共同使用来构建DApps。
   Whisper: 一种去中心化（P2P）消息系统。与Web3和Swarm一起使用来构建DApps.

20.零地址：特殊的以太坊地址，所有20个位都为0

21.开源、公开的区块链通常包括以下组件：
    一个连接参与者，并传播交易和包含已验证交易的区块的点对点网络，基于标准的“gossip“协议。
    状态机中实现的一系列共识规则。
    消息，以交易的形式表示，代表状态转移。
    根据共识规则处理交易的状态机。
    分布式数据库，区块链，记录所有状态转移的日志。
    共识算法（例如，Proof-of-Work），通过强制参与者竞争并使用共识规则约束他们，来分散区块链的控制权。
    上述内容的一个或多个开源软件实现。

22.以太坊是图灵完备的事实意味着任何复杂的程序都可以在以太坊中计算

24.Dapps是一个基于开放的，去中心化的，点对点基础架构服务的web应用程序。至少由以下部分组成：区块链上的智能合约；一个web前端用户界面；
   许多Dapp还包括其他去中心化组件，例如：去中心化(p2p)存储协议和平台；去中心化(p2p)消息传递协议和平台

25.几款常用的钱包：
    MetaMask:是一款浏览器扩展钱包，可在你的浏览器中运行，可以链接到各种以太坊节点和测试区块链
    (我的助记符:fault betray indoor pill immune discover ritual unable forget truly million ski;私钥：FCC014D0CE2F4FAD149BB1582066D0A9FE6A05F45B30447CA917DD41BD3A2C5E)
    Jaxx是一款多平台和多币种的钱包，可在Android，IOS，windows,mac和linux中使用
    MyEtherWallet是一款基于网络的钱包，可在任何浏览器中运行。它具有多个复杂的功能，我们将在许多示例中探讨这些功能。
    Emerald Wallet钱包设计用于以太坊经典区块链，但与其他以太坊区块链兼容。它是一款开源桌面应用程序，适用于Windows，Mac和Linux。Emerald钱包可以运行一个完整的节点或连接到一个公共的远程节点，工作在“轻量”模式下。它还有一个配套工具来在命令行中执行所有操作。

26.以太坊账户：外部所有账户（EOAs）和合约。外部所有账户是那些拥有私人密钥的账户，它控制对资金或合约的访问。现在，你可能猜测还有另一种帐户，_合约_帐户。合约账户由以太坊区块链记录，由EVM执行的软件程序的逻辑所拥有（和控制）。
   Solidity：编写智能合约的语言
   在区块链上注册合约涉及创建一个特殊交易，其目标是地址0x0000000000000000000000000000000000000000，也称为_zero address_。零地址是一个特殊的地址，告诉以太坊区块链你想注册一个合约。幸运的是，Remix IDE将为你处理所有这些交易并将交易发送给MetaMask
   Remix IDE可用于在主网和测试网上部署和交互智能合约，包括Ropsten，Rinkeby和Kovan（Web3提供者使用Infura地址和API密钥或通过Injected Web3使用MetaMask中选择的网络）和Ganache（ Web3提供端点http://localhost:8545）

27.kovan获取faucet:
   faucet：https://gitter.im/kovan-testnet/faucet
   Kovan testnet支持各种方法来请求测试ether。 更多信息可以在 https://github.com/kovan-testnet/faucet/blob/master/README.md 找到。
   https://medium.com/@Digix/announcing-kovan-a-stable-ethereum-public-testnet-10ac7cb6c85f
   https://kovan-testnet.github.io/website/
   测试链：https://kovan.etherscan.io/

28.公钥和私钥：
   公钥使用椭圆曲线乘法和私钥计算，这是不可逆的：K = k * G，其中_k_是私钥，G_是一个称为_generator point_的常数点，_K_是结果公钥。如果你知道_K，那么称为“寻找离散对数”的逆运算就像尝试所有可能的_k_值一样困难，也就是蛮力搜索。
⚠️ 以太坊使用与比特币完全相同的椭圆曲线，称为 secp256k1

   私钥可以转换为公钥，但公钥不能转换回私钥，因为数学只能单向工作。
   在以太坊中，你可以看到公钥以66个十六进制字符（33字节）的十六进制序列表示。这是从行业联盟标准高效密码组（SECG）提出的标准序列化格式采用的，在http://www.secg.org/sec1-v2.pdf[Standards for Efficient Cryptography（SEC1）]中有记载。该标准定义了四个可用于识别椭圆曲线上点的可能前缀：

   Prefix    Meaning                 Length (bytes counting prefix)

   0x00      Point at Infinity              1

   0x04      Uncompressed Point             65

   0x02     Compressed Point with even Y    33

   0x03     Compressed Point with odd Y     33

以太坊只使用未压缩的公钥，因此唯一相关的前缀是（十六进制）04。顺序连接公钥的X和Y坐标：

04 + X-coordinate (32 bytes/64 hex) + Y coordinate (32 bytes/64 hex)

⚠️ 以太坊地址不区分大小写，所有钱包都应该接受以大写字母或小写字母表示的以太坊地址，在解释上没有任何区别。

29.以太坊钱包：
         非确定性钱包                                                               确定性钱包
描述    每个密钥都是从随机数中独立生成的。密钥不相互关联                               所有密钥都来自单个主密钥，称为_种子_ seed。这种类型的钱包中的所有钥匙都是相互关联的，
         如：keythereum                                                        如果有原始种子，可以再次生成。确定性钱包中使用了许多不同的 密钥推导方法

                                                                         https://github.com/inoutcode/ethereum_book/raw/master/images/hd_wallet.png

优势                                                                      树状结构可以用来表达额外的组织含义；用户可以创建一系列公钥而无需访问相应的私钥。这允许HD钱包用于不安全的服务器上，或者仅用于只查看或只接收的地方，其中钱包没有可以花费资金的私钥。

特点                                                                      可以跨钱包导入导出助记词或seed，无需私钥


以太坊钱包的标准：
    基于 BIP-39 的助记词
    基于 BIP-32 的HD钱包
    基于 BIP-43 的多用途HD钱包
    基于 BIP-44 的多币种和多账户钱包
⚠️ 助记词：是表示（编码）派生确定性钱包的种子的随机数的单词序列。单词序列足以重新创建种子，从而重新创建钱包和所有派生的密钥。使用助记词实现的确定性钱包会在首次创建钱包时向用户展示12至24个字的序列。该单字序列是钱包的备份，可用于在相同或任何兼容的钱包应用程序中恢复和重新创建所有密钥。
也可使用密码+助记符生成 私钥
BIP-39 以许多不同的编程语言实现为库：
python-mnemonic：SatoshiLabs团队提出的BIP-39标准的参考实现，使用Python
Consensys/eth-lightwallet：轻量级JS Ethereum节点和浏览器钱包（使用BIP-39）
npm/bip39：比特币BIP39的JavaScript实现：用于生成确定性密钥的助记词

⚠️ 种子：助记符字表示长度为128到256位的熵。然后使用使用密钥扩展函数PBKDF2将熵导出成更长的（512位）种子。然后使用生成的种子构建确定性钱包并派生其密钥。种子是128、256或512位随机数
密钥扩展函数有两个参数：助记词和_salt_。在密钥扩展函数中使用盐的目的是使得构建能够进行暴力攻击的查找表不可行。在BIP-39标准中，盐有另一个目的 —— 它允许引入密码，作为保护种子的附加安全因素，我们将在 BIP-39中的可选密码短语 中详细描述。
步骤7到9中从 生成助记词 描述的过程后继续：
PBKDF2密钥扩展函数的第一个参数是步骤6产生的助记词。
PBKDF2密钥扩展函数的第二个参数是盐。盐由用户提供的密码字符串和“mnemonic”组合起来。
PBKDF2使用2048轮HMAC-SHA512哈希算法，扩展助记词和盐，生成512位的种子。

⚠️ 私钥：每个私钥都由种子确定性地派生而来，这使得可以在任何兼容的HD钱包中从该种子重新创建整个HD钱包。这使得备份，恢复，导出和导入包含数千乃至数百万个密钥的HD钱包变得很容易，只需传输根种子的助记词即可

⚠️ 公钥：两种派生子公钥的方法：从子私钥派生，或直接从父公钥派生 （公私钥一一对应）

强化子密钥派生：如果你想使用xpub的便利来派生公钥的分支，而不会让自己面临泄漏链码的风险，所以应该从强化父项而不是普通父项派生。作为最佳做法，主密钥的1级子密钥级始终通过强化派生派生，以防止主密钥受到破坏。
强化派生函数使用父私钥来派生子链码，而不是父公钥。

正常和强化派生的索引号
BIP-32派生函数中使用的索引号是一个32位整数。为了便于区分通过常规派生函数派生的密钥与通过强化派生函数派生的密钥，该索引号分为两个部分。0到231-1（0x0到0x7FFFFFFF）之间的索引号仅用于常规派生。231和232-1（0x80000000至0xFFFFFFFF）之间的索引号仅用于强化派生。因此，如果索引号小于231，则子项是常规的，如果索引号等于或大于231，则子项是强化的。

为了使索引号更容易阅读和展示，强化子项的索引号从零开始展示，但带有一个主要符号。第一个正常子密钥展示为0，而第一个强化子密钥（索引0x80000000）展示为0'。然后，按顺序，第二个强化子密钥将具有索引0x80000001，并将展示为1'，依此类推。当你看到HD钱包索引i'时，表示231+i。

HD钱包密钥标识符（路径）
HD钱包中的密钥使用“路径”命名约定来标识，树的每个级别都用斜杠（/）字符分隔。从主密钥派生的私钥以“m”开头。从主公钥派生的公钥以“M”开始。因此，主私钥的第一个子私钥为m/0。第一个子公钥是M/0。第一个孩子的第二个孩子是m/0/1，依此类推。

HD path	            Key described

m/0                 The first (0) child private key from the master private key (m)

m/0/0               The first grandchild private key of the first child (m/0)

m/0'/0              The first normal grandchild of the first hardened child (m/0')

m/1/0               The first grandchild private key of the second child (m/1)

M/23/17/0/0         The first great-great-grandchild public key of the first great-grandchild of the 18th grandchild of the 24th child

⚠️ HD钱包树状结构导航：

BIP-43：建议使用第一个强化子密钥作为表示树结构“目的”的特殊标识符。基于BIP-43，HD钱包应该只使用树的一个1级分支，索引号通过定义其目的来标识树的其余部分的结构和名称空间。例如，仅使用分支m/i'/的HD钱包表示特定目的，而该目的由索引号“i”标识。

扩展该规范，BIP-44提出了一个多币种多帐户结构作为BIP-43下的“目的”号码+44'+。遵循BIP-44的HD钱包通过仅使用树的一个分支的事实来标识：m / 44'/。

BIP-44指定了包含五个预定义层级的结构：

m / purpose' / coin_type' / account' / change / address_index
 第一级“purpose”始终设置为+44'+。第二级“coin_type”指定加密货币类型，允许多货币HD钱包，其中每种货币在第二级下具有其自己的子树。标准文件中定义了几种货币，称为SLIP0044：https://github.com/satoshilabs/slips/blob/master/slip-0044.md

e.g.: Ethereum 是 m/44'/60', Ethereum Classic is m/44'/61', Bitcoin 是 m/44'/0', 所有货币的 Testnet 是 m/44'/1'.

树的第三层“account”, 允许用户将他们的钱包分割成逻辑上的子账户，用于会计或组织管理目的。例如HD钱包可能包含两个以太坊“账户”： m/44'/60'/0' 和 m/44'/60'/1'. 每个账户都是自己的子树的根

在路径的第四层“change”时，HD钱包有两个子树，一个用于创建接收地址，另一个用于创建零钱地址。以太坊只使用“接收”路径，因为没有零钱地址这样的东西,请注意，虽然以前的层级使用强化派生，但此层级使用正常派生。这是为了允许树的这个层级导出扩展公钥在非安全环境中使用,
可用地址由HD钱包作为第四级的孩子派生，使树的第五级成为“address_index”

如：m/44'/60'/0'/0/2 在主账户中以太坊付款的第三个接收地址为M/44'/60'/0'/0/2


⚠️ 以太坊的私钥：私钥 、公钥、地址、钱包 ：用比特币的bitcore-lib来实现

⚠️地址：通过对公钥K做sha3（keccak256）哈希，得到一个32字节的结果，取其中的后20字节，就是以太坊的地址了

https://github.com/trapp/ethereum-bip44

搜索如：Get Private and Public Key from BIP44 Master Private Key
       ethereumjs/ethereumjs-util

⚠️ 由于各个语言对于长度的限制不同，所以地址在rpc返回结果中以16进制显示

-----------------------------    交易    --------------------------------------
⚠️ nonce 交易随机数  该nonce是一个基于零的计数器，意味着第一个交易的nonce是0.

   1. 标记已确认交易：与此地址发送的交易数量相等的标量值，根据来源于此地址的已确认交易的数量动态计算的；或者，对于具有关联代码的帐户，表示此帐户创建的合约数量。

   2. 防重：使用nonce确保所有节点计算相同的余额，并正确地对交易进行排序，相当于比特币中用于防止“双重支付”的机制。但是，因为以太坊跟踪账户余额并且不会单独跟踪独立的币（在比特币中称为UTXO），所以只有在账户余额计算错误时才会发生“双重支付”。nonce机制可以防止这种情况发生。

   3. 获取下一个nonce:⚠️ 当你构建生成交易的应用程序时，无法依赖 getTransactionCount 处理未完成的交易。只有在待处理和已确认相同（所有未完成的交易都已确认）时，才能信任 getTransactionCount 的输出以开始你的nonce计数器。
         Parity的JSON RPC接口提供 parity_nextNonce 函数，该函数返回应在交易中使用的下一个nonce。parity_nextNonce 函数可以正确地计算nonce，即使你连续快速构建多个交易，但没有确认它们。

   4.nonce如果不连续将会拥堵：
     nonce的间隔，重复的nonce和确认
     如果你正在以编程方式创建交易，跟踪nonce是十分重要的，特别是如果你同时从多个独立进程执行此操作。
     以太坊网络根据nonce顺序处理交易。这意味着如果你使用nonce +0+传输一个交易，然后传输一个具有nonce +2+的交易，则第二个交易将不会被挖掘。它将存储在mempool中，以太坊网络等待丢失的nonce出现。所有节点都会假设缺少的nonce只是延迟了，具有nonce +2+的交易被无序地接收到。
     如果你随后发送一个丢失的nonce 1+的交易，则交易（交易+1+和+2）将被开采。一旦你填补了空白，网络可以挖掘它在mempool中的失序交易。
     这意味着如果你按顺序创建多个交易，并且其中一个交易未被挖掘，则所有后续交易将“卡住”，等待丢失的事件。交易可以在nonce序列中产生无意的“间隙”，比如因为它无效或gas不足。为了让事情继续进行，你必须传输一个具有丢失的nonce的有效交易。
     另一方面，如果你不小心重复一个nonce，例如传输具有相同nonce的两个交易，但收件人或值不同，则其中一个将被确认，另一个将被拒绝。哪一个被确认将取决于它们到达第一个接收它们的验证节点的顺序。

   5.并发，交易的发起和随机数:并发难度大，所以交易所钱包用单线程来处理所有取款交易

⚠️ 交易 gas ：以太坊燃料，钱包可以在他们发起的交易中调整 gasPrice，以更快地确认（挖掘）交易。gasPrice 越高，交易可能被验证的速度越快；对于合约交易花费的gas与调用合约的复杂度相关

⚠️ to目的地址：(无法验证目的地址)

   1.一个正常的20字节的以太坊地址，可以是EOA地址或合约地址
   2.任何20字节的值都被认为是有效的。如果20字节的值对应于没有相应私钥的地址，或没有相应的合约，则该交易仍然有效；该地址上的ether永久不可使用


⚠️ 交易的价值和数据

   交易的只要"负载"包含在两个字段中value和data.交易可以同时具有value和data，只有value，只有data，或没有value和data。所有四种组合都是有效的。只有value的交易是 支付 payment。只有data的交易是 调用 invocation。既没有value也没有data的交易，这可能只是浪费gas！但它仍然有可能。

  将value传递给EOA和合约：
      当你构建包含 value 的以太坊交易时，它等同于_payment_。目的地址是EOA账户地址：发送的value添加到地址的余额中
  目标地址（to）是合约：则EVM将执行合约并尝试调用你的交易的 data 中指定的函数（参见 [invocation] ）。如果你的交易中没有 data，那么EVM将调用目标合约的 fallback 函数，如果该函数是payable，则将执行该函数以确定下一步该做什么。
  合约可以通过在调用付款功能时立即抛出异常或由付款功能中编码的条件确定来拒绝收款。如果付款功能成功终止（没有意外），则更新合约状态以反映合约的ether余额增加

  ⚠️ 发送到合约的 data 是一个十六进制序列化的编码=>函数选择器（function selector）：函数_prototype_的Keccak256哈希的前4个字节。这使EVM能够明确地识别你希望调用的功能

   如：函数参数
       函数的参数，根据EVM定义的各种基本类型的规则进行编码。

       我们来看一个简单的例子，它来自我们的[solidity_faucet_example]。在+Faucet.sol+中，我们为取款定义了一个函数：

     function withdraw(uint withdraw_amount) public {
     withdraw函数的_prototype_被定义为包含函数名称的字符串，随后是括号中括起来的每个参数的数据类型，并用单个逗号分隔。函数名称是+withdraw+，它只有一个参数是uint（它是uint256的别名）。所以+withdraw+的原型将是：

     withdraw(uint256)
     我们来计算这个字符串的Keccak256哈希值（我们可以使用truffle控制台或任何JavaScript web3控制台来做到这一点）：

     web3.sha3("withdraw(uint256)");
     '0x2e1a7d4d13322e7b96f9a57413e1525c250fb7a9021cf91d1540d5b69f16a49f'
     散列的前4个字节是 0x2e1a7d4d。这是我们的“函数选择器”的值，它会告诉EVM我们想调用哪个函数。

     接下来，让我们计算一个值作为参数 withdraw_amount 传递。我们要取款0.01 ether。我们将它编码为一个十六进制序列化的大端序无符号256位整数，以wei为单位：

     withdraw_amount = web3.toWei(0.01, "ether");
     '10000000000000000'
     withdraw_amount_hex = web3.toHex(withdraw_amount);
     '0x2386f26fc10000'
     现在，我们将函数选择器添加到这个参数上（填充为32字节）：

     2e1a7d4d000000000000000000000000000000000000000000000000002386f26fc10000
     这就是我们的交易的 data，调用 withdraw 函数并请求0.01 ether作为 withdraw_amount
      ⚠️（如果调用合约方法有多个参数，则在方法名散列后添加32*参数个数个字节）
   ⚠️ 特殊交易：合约注册
      有一种特殊的带有data，没有value的交易。表示注册一个新的合约。合约登记交易被发送到一个特殊的目的地地址，即零地址。简而言之，合约注册交易中的+to+字段包含地址 0x0。该地址既不代表EOA（没有相应的私人/公共密钥对）也不代表合约。它永远不会花费ether或启动交易。它仅用作目的地，具有“注册此合约”的特殊含义

      尽管零地址仅用于合约注册，但它有时会收到来自各个地址的付款

   ⚠️ 数字签名 椭圆曲线数字签名(ECDSA)

      用途：1.签名证明私钥的所有者，即以太坊账户的所有者，已经授权支付ehter或执行合约
           2.授权的证明是_undeniable_（不可否认）
           3.签名证明交易数据在交易签名后没有也不能被任何人修改。

      工作过程：1.使用私钥（签名密钥）从消息（交易）中创建签名的算法
               2.允许任何人仅使用消息和公钥来验证签名的算法

              ⚠️ 当我们说“签署交易”时，我们实际上是指“签署RLP序列化交易数据的Keccak256哈希”，️签名应用于交易数据的哈希，而不是交易本身

      要在以太坊签署交易，发件人必须：
         创建一个包含九个字段的交易数据结构：nonce，gasPrice，startGas，to，value，data，v，r，s
         生成交易的RLP编码的序列化消息
         计算此序列化消息的Keccak256哈希
         计算ECDSA签名，用发起EOA的私钥签名散列
         在交易中插入ECDSA签名计算出的 r 和 s 值

     原始交易创建和签名:让我们创建一个原始交易并使用 ethereumjs-tx 库对其进行签名

   ⚠️ eip-155 重放攻击保护--->在签名之前指定了重播攻击保护（replay-attack-protected）的交易编码,这确保了为一个区块链（例如以太坊主网）创建的交易在另一个区块链（例如Ethereum Classic或Ropsten测试网络）上无效

      EIP-155向交易数据结构添加了三个字段 v，r+和+s。r+和+s 字段被初始化为零。这三个字段在编码和散列_之前_被添加到交易数据中。因此，三个附加字段会更改交易的散列，稍后将应用签名。通过在被签名的数据中包含链标识符，交易签名可以防止任何更改，因为如果链标识符被修改，签名将失效。因此，EIP-155使交易无法在另一个链上重播，因为签名的有效性取决于链标识符
      签名前缀字段+v+被初始化为链标识符，其值为：

      Chain                Chain ID

      Ethereum main net       1

      Morden (obsolete), Expanse   2

      Ropsten                       3

      Rinkeby                       4

      Rootstock main net            30

      Rootstock test net            31

      Kovan                     42

      Ethereum Classic main net   61

      Ethereum Classic test net   62

      Geth private testnets       1337


   ⚠️ 签名前缀值（v）和公钥恢复
      如交易的结构所述，交易消息不包含任何“from”字段。这是因为发起者的公钥可以直接从ECDSA签名中计算出来。一旦你有公钥，你可以很容易地计算出地址。恢复签名者公钥的过程称为_公钥恢复_





