1.智能合约一旦部署，不可更改，修改智能合约的唯一方法是部署新实例

2.一旦编译完成，它们就会随着转移到特殊的合约创建地址的交易被部署到以太坊区块链中

3.每个合约都由以太坊地址标识，该地址源于作为发起账户和随机数的函数的合约创建交易。合约的以太坊地址可以在交易中用作接收者，可将资金发送到合约或调用合约的某个功能。

4.以太坊的所有智能合约均由EOA发起的交易执行。合约可以调用另一个合约，其中又可以调用另一个合约，等等

5.交易是 原子性的 atomic，无论他们调用多少合约或这些合约在被调用时执行的是什么。交易完全执行，仅在交易成功终止时记录全局状态（合约，帐户等）的任何更改。成功终止意味着程序执行时没有错误并且达到执行结束。如果交易由于错误而失败，则其所有效果（状态变化）都会“回滚”，就好像交易从未运行一样。失败的交易仍存储在区块链中，并从原始账户扣除gas成本，但对合约或账户状态没有其他影响

6.合约不可更改，可以删除，该操作话费"负的gas",从而激励储存状态的释放，但之前交易历史不会删除

⚠️ 以太坊合约应用程序二进制接口（ABI）

   ABI是将数据编码到机器码，和从机器码解码数据的主要方式：在计算机软件中，应用程序二进制接口（ABI）是两个程序模块之间的接口；通常，一个在机器代码级别，另一个在用户运行的程序级别

7.solidity文档：https://solidity.readthedocs.io/en/latest/

智能合约合约函数格式：

function FunctionName([parameters]) {public|private|internal|external} [pure|constant|view|payable] [modifiers] [returns (<return types>)]

⚠️ FunctionName
   定义函数的名称，用于通过交易（EOA），其他合约或同一合约调用函数。每个合约中的一个功能可以定义为不带名称的，在这种情况下，它是_fallback_函数，在没有指定其他函数时调用该函数。fallback函数不能有任何参数或返回任何内容。

⚠️ parameters
   在名称后面，我们指定必须传递给函数的参数，包括名称和类型。在我们的+Faucet+示例中，我们将+uint withdraw_amount+定义为+withdraw+函数的唯一参数

public
Public是默认的，这些函数可以被其他合约，EOA交易或合约内部调用。在我们的+Faucet+示例中，这两个函数都被定义为public。

external
外部函数就像public一样，但除非使用关键字this作为前缀，否则它们不能从合约中调用。

internal
内部函数只能在合约内部"可见"，不能被其他合约或EOA交易调用。他们可以被派生合约调用（继承的）。

private
private函数与内部函数类似，但不能由派生的合约调用（继承的）。

请记住，术语 internal 和 private 有些误导性。公共区块链中的任何函数或数据总是_可见的_，意味着任何人都可以看到代码或数据。以上关键字仅影响函数的调用方式和时机。


⚠️下一组关键字（pure, constant, view, payable）会影响函数的行为：

constant/view
标记为_view_的函数，承诺不修改任何状态。术语_constant_是_view_的别名，将被弃用。目前，编译器不强制执行_view_修饰器，只产生一个警告，但这应该成为Solidity v0.5中的强制关键字。

pure
纯(pure)函数不读写任何变量。它只能对参数进行操作并返回数据，而不涉及任何存储的数据。纯函数旨在鼓励没有副作用或状态的声明式编程。

payable
payable函数是可以接受付款的功能。没有payable的函数将拒绝收款，除非它们来源于coinbase（挖矿收入）或 作为 SELFDESTRUCT（合约终止）的目的地。在这些情况下，由于EVM中的设计决策，合约无法阻止收款。

正如你在+Faucet+示例中看到的那样，我们有一个payable函数（fallback函数），它是唯一可以接收付款的函数。


⚠️ 合约的生命周期始于EOA或其他合约的创建交易。如果有一个构造函数，它将在相同的创建交易中调用，并可以在创建合约时初始化合约状态。

⚠️ 合约的销毁：selfdestruct(address recipient);  //该函数采用一个参数：地址以接收合约帐户中剩余的余额

Solidity中的错误由四个函数处理：assert, require, revert, 和 throw（现在已弃用）



